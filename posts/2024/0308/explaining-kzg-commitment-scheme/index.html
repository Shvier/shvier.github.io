<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Explaining KZG Commitment Scheme - Barry's Site</title>
<meta name=theme-color><meta name=description content="Commitment Scheme In zero-knowledge proofs, the prover normally commits to the statement he wants to prove and reveals the commitment later. Since he cannot tamper with the commitment, the soundness of a ZKP is guaranteed. This is the basic idea of a commitment scheme. In modern zkSNARKs, we can commit to the data in any type. KZG is a commitment scheme for polynomials. That is, the prover commits to a polynomial and reveals a random evaluation point."><meta name=author content="Barry's Site"><link rel="preload stylesheet" as=style href=https://shvier.github.io/main.min.css><link rel=preload as=image href=https://shvier.github.io/theme.png><link rel=preload as=image href=https://shvier.github.io/twitter.svg><link rel=preload as=image href=https://shvier.github.io/github.svg><script defer src=https://shvier.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script><link rel=icon href=https://shvier.github.io/favicon.ico><link rel=apple-touch-icon href=https://shvier.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.126.1"><meta itemprop=name content="Explaining KZG Commitment Scheme"><meta itemprop=description content="Commitment Scheme In zero-knowledge proofs, the prover normally commits to the statement he wants to prove and reveals the commitment later. Since he cannot tamper with the commitment, the soundness of a ZKP is guaranteed. This is the basic idea of a commitment scheme. In modern zkSNARKs, we can commit to the data in any type. KZG is a commitment scheme for polynomials. That is, the prover commits to a polynomial and reveals a random evaluation point."><meta itemprop=datePublished content="2024-03-08T20:05:35-05:00"><meta itemprop=dateModified content="2024-08-23T20:06:40+00:00"><meta itemprop=wordCount content="1074"><meta property="og:url" content="https://shvier.github.io/posts/2024/0308/explaining-kzg-commitment-scheme/"><meta property="og:site_name" content="Barry's Site"><meta property="og:title" content="Explaining KZG Commitment Scheme"><meta property="og:description" content="Commitment Scheme In zero-knowledge proofs, the prover normally commits to the statement he wants to prove and reveals the commitment later. Since he cannot tamper with the commitment, the soundness of a ZKP is guaranteed. This is the basic idea of a commitment scheme. In modern zkSNARKs, we can commit to the data in any type. KZG is a commitment scheme for polynomials. That is, the prover commits to a polynomial and reveals a random evaluation point."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-08T20:05:35-05:00"><meta property="article:modified_time" content="2024-08-23T20:06:40+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Explaining KZG Commitment Scheme"><meta name=twitter:description content="Commitment Scheme In zero-knowledge proofs, the prover normally commits to the statement he wants to prove and reveals the commitment later. Since he cannot tamper with the commitment, the soundness of a ZKP is guaranteed. This is the basic idea of a commitment scheme. In modern zkSNARKs, we can commit to the data in any type. KZG is a commitment scheme for polynomials. That is, the prover commits to a polynomial and reveals a random evaluation point."><link rel=canonical href=https://shvier.github.io/posts/2024/0308/explaining-kzg-commitment-scheme/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://shvier.github.io/>Barry's Site</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-14 lg:mt-0 lg:items-center"><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/barryllvm target=_blank rel=me>twitter
</a><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/Shvier target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">Explaining KZG Commitment Scheme</h1><div class="text-sm opacity-50" style=display:flex;align-items:center><time>Created on Mar 8, 2024</time>
<time>&nbsp•&nbspModified on Aug 23, 2024</time>
&nbsp•&nbspDraft
      
      
 </div></header><section><h2 id=commitment-scheme>Commitment Scheme</h2><p>In zero-knowledge proofs, the prover normally commits to the statement he wants to prove and reveals the commitment later. Since he cannot tamper with the commitment, the soundness of a ZKP is guaranteed. This is the basic idea of a commitment scheme. In modern zkSNARKs, we can commit to the data in any type. KZG is a commitment scheme for polynomials. That is, the prover commits to a polynomial and reveals a random evaluation point. If the evaluation is correct, the verifier can believe the prover knows such a polynomial with significant confidence due to the Schwartz-Zippel lemma.</p><h2 id=polynomial-interpolation>Polynomial Interpolation</h2><p>To prove the statement is correct, the first thing that the prover needs to do is construct the polynomial. We know a polynomial can be represented in two forms, coefficient and point-value. The KZG commitment scheme works with the coefficients, which means the prover has to convert the evaluations into coefficients first. This is where the polynomial interpolation comes from. There are some commonly known ways of interpolating a polynomial like, the Lagrange interpolation, the Newton interpolation, and the Vandermonde matrix. I will not explain the details of these methods in this post. See <a href=../../0820/polynomial-interpolation-and-fft>this post</a> if you are interested in polynomial interpolation. It is worth noting the polynomial interpolation normally works with the fast Fourier transform (FFT) and root of unity for the efficiency.</p><h2 id=elliptic-curve-and-pairing>Elliptic Curve and Pairing</h2><p>By the discrete logarithm assumption (DL), the Pedersen commitment features binding and perfect hiding. The idea of KZG commitment scheme is use the Pedersen commitment to commit to the coefficients of the polynomial. Suppose $\{a_0,a_1,a_2,\dots,a_{n-1}\}$ are the coefficients of $f$, the KZG commitment to $f$ is $g^{a_0+\tau{a_1}+\tau^2{a_2}+\cdots+\tau^{n-1}a_{n-1}}$. Due to DL, it is infeasible for one to compute $\tau$ given $\{g,g^{\tau},g^{\tau^2},\dots,g^{\tau^{n-1}}\}$, which is why the KZG commitment scheme requires a trusted setup to publish the tau thing in advance. In practice, you may want to add an extra polynomial, somewhere call it the mask polynomial, to improve the security of the commitment. Specially, we need to generate another generator $h$ on the same field and the relation between $g$ and $h$ should not be known to any party. We use this $h$ to commit to a randomly generated polynomial with the same degree as $f$. Let call it $\hat{f}$. So the commitment will be $g^{f(\tau)}h^{\hat{f}(\tau)}$.</p><p>It seems good so far but we cannot do anything with this commitment $g^{f(\tau)}h^{\hat{f}(\tau)}$ because only addition exists in DL. That is, we have to know the $x$ or $y$ if we want to compute $g^{xy}$ given $g^x,g^y$; we get $g^{x+y}$ if we multipily $g^x$ and $g^y$ (the computational Diffie-Hellman, CDH). Why is multiplication so important? The reason is we exploit the Schwart-Zippel lemma to verify the polynomial is correct by opening a random evaluation point, i.e., we need to prove the opening point is the root of the polynomial through the equation $f(x)-b=(x-a)\cdot{q(x)}$, where $q(x)$ is the quotient polynomial. Here is why KZG requires the pairing. A pairing (bilinear) allows we map the elements in two groups to the elements in a target group, denoted by $e: G_1\times{G_2}\rightarrow{G_T}$. For example, given $x\in{G_1},y\in{G_2},z\in{G_T}$ and $z=xy$, we can check $g^z=g^{xy}$ using the pairing through</p>$$
e(g_1^x,g_2^y)=e(g_1,g_2)^{xy}=e(g_1,g_2)^z=e(g_1,g_2^z)
$$<p>The pairing normally relies on the assumption of the elliptic curve, which is why KZG requires a pairing-friendly group. After we commit to a polynomial using KZG, what we get is a point on the elliptic curve. Now we can verify the KZG commitment is correct given the commitment to the quotient polynomial and the opening point by checking</p>$$
e(g_1^{f(\epsilon)}/g_1^b,g_2)=e(g_1^{q(\epsilon)},g_2^{\tau-a})
$$<p>where $f(a)=b$. If we use the mask polynomial technique, the pairing will become</p>$$
e(g_1^{f(\epsilon)}h_1^{\hat{f}(\epsilon)}/(g_1^bh_1^r),g_2)=e(g_1^{q(\epsilon)}h_1^{\hat{q}(\epsilon)},g_2^{\tau-a})
$$<p>It is worth noting we can reveal the committed evaluation $g_1^bh_1^r$ instead of $b$ to hide the actual value. This variant does not violate the soundness of KZG due to the binding property of Pedersen commitment.</p><h2 id=kzg-batch-opening-scheme>KZG Batch Opening Scheme</h2><p>Since the pairing is an expensive computation, we want to reduce the pairing operations to optimize the computing time. The original KZG opening scheme requires one pairing for each opening evaluation point. That means opening $$ evaluation points for $m$ polynomials requires $mn$ pairings. One intuitive optimization is linearly combine the polynomials for the same evaluation point and prove the summed polynomial is correct. More precisely, given polynomials $\{f_1,f_2,f_3,\dots,f_m\}$, the prover and the verifier run the following protocol</p><ol><li>Prover commits to all polynomials and publishes the commitments</li><li>Verifier sends a random challenge $\gamma$ to linearly combine the polynomials</li><li>Prover computes $w=\sum_{i=1}^m\gamma^{i-1}f_i$</li><li>Verifier sends a random evaluation point $\zeta$</li><li>Prover opens $\{f_i\}$ at $\zeta$, computes the quotient polynomial $q(x)$ such that $q=w/(x-\zeta)$, commits to $q$ and publish its commitment</li><li>Verifier checks<ul><li>the evaluations of $\{f_i\}$ and $q$ at $\zeta$ are correct</li><li>$w$ is constructed correctly through $\sum_{i=1}^m\gamma^{i-1}f_i(\zeta)=q(\zeta)\cdot(\zeta^n-1)$</li></ul></li></ol><p>The point of this optimization is introduced in <a href=https://eprint.iacr.org/2019/953>GWC19</a>. Boneh et al. introduced another way to reduce the verifying time by moving some of the verifier&rsquo;s work to the prover&rsquo;s in <a href=https://eprint.iacr.org/2020/081>this paper</a>. If you want to know more about the batch opening techniques, there is a paper named <a href=https://eprint.iacr.org/2021/1167>fflonk</a>. The basic idea of fflonk is instead of opening multiple polynomials at one point, opening one polynomial at multiple points. This might sound similar as the idea in GWC19, but they leveraged the properties of FFT to reduce the computing further.</p><h2 id=the-zero-knowledge-extension>The Zero-Knowledge Extension</h2><p>Although a Pedersen commitment provides perfect hiding, the KZG commitment still leaks the information of the opening evaluation point. To avoid this, we can open the committed value of the evaluation. However, this solution may not satisfy some cases, e.g., when linearly combining the evaluations through the batch opening scheme, the summation of the random factors of the committed evaluations does not equal the random factor of the commitment to the quotient polynomial. Boneh et al. introduced a solution, the zero-knowledge extension of the KZG commitment, in <a href=https://hackmd.io/@dabo/B1U4kx8XI>this post</a>. The basic idea is interpolating $t$ more points of the original polynomial, where $t$ is the number of the opening points. Note after interpolating $t$ more points, we can construct a simulator to generate the transcript that is computationally indistinguishable from the transcript produced by the prover. For example, if we want to open $f$ at one point, then we generate two random numbers $\alpha,\beta$ and incrementally interpolate $f$ such that $f(\alpha)=\beta$. And the prover and the verifier should open $f$ at points outside the domain of $f$ to avoid leaking the information of the evaluation.</p></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://shvier.github.io/posts/2024/0813/a-brief-introduction-to-secure-multiparty-computation/><span class=mr-1.5>←</span><span>A Brief Introduction to Secure Multiparty Computation (MPC)</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://shvier.github.io/posts/2024/0131/zk-hack-iv-puzzle-2-supervillain/><span>ZK Hack IV Puzzle 2: Supervillain</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-50"><div class=mr-auto>&copy; 2024
<a class=link href=https://shvier.github.io/>Barry's Site</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Theme Paper</a>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css integrity="sha512-mQwom8Ns4op+H29oDkD/LXO/OsXPvCFfkgZkFAVrhhePzRLU8NUI3Nkm43NhWUSmj3p5Cca2HTEkMQmXQRwDQQ==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin=anonymous referrerpolicy=no-referrer onload=renderMathInElement(document.body)></script></footer></body></html>