<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>A Brief Introduction to Secure Multiparty Computation (MPC) - Barry's Site</title>
<meta name=theme-color><meta name=description content="What Is MPC MPC is a cryptographic protocol that allows some parties to perform some computing tasks while achieving
(i) privacy: no party can know anything except the output of the computation (ii) correctness: each party receives the correct output While there are some other properties of MPC like fairness, I just listed the two most intuitive properties, and we will not discuss any security proofs for MPC as this is a simply explained post."><meta name=author content="Barry's Site"><link rel="preload stylesheet" as=style href=https://shvier.github.io/main.min.css><link rel=preload as=image href=https://shvier.github.io/theme.png><link rel=preload as=image href=https://shvier.github.io/twitter.svg><link rel=preload as=image href=https://shvier.github.io/github.svg><script defer src=https://shvier.github.io/highlight.min.js onload=hljs.initHighlightingOnLoad()></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"],["$","$"]]}}</script><link rel=icon href=https://shvier.github.io/favicon.ico><link rel=apple-touch-icon href=https://shvier.github.io/apple-touch-icon.png><meta name=generator content="Hugo 0.126.1"><meta itemprop=name content="A Brief Introduction to Secure Multiparty Computation (MPC)"><meta itemprop=description content="What Is MPC MPC is a cryptographic protocol that allows some parties to perform some computing tasks while achieving
(i) privacy: no party can know anything except the output of the computation (ii) correctness: each party receives the correct output While there are some other properties of MPC like fairness, I just listed the two most intuitive properties, and we will not discuss any security proofs for MPC as this is a simply explained post."><meta itemprop=datePublished content="2024-08-13T17:00:30-04:00"><meta itemprop=dateModified content="2024-08-23T20:06:40+00:00"><meta itemprop=wordCount content="1662"><meta property="og:url" content="https://shvier.github.io/posts/2024/0813/a-brief-introduction-to-secure-multiparty-computation/"><meta property="og:site_name" content="Barry's Site"><meta property="og:title" content="A Brief Introduction to Secure Multiparty Computation (MPC)"><meta property="og:description" content="What Is MPC MPC is a cryptographic protocol that allows some parties to perform some computing tasks while achieving
(i) privacy: no party can know anything except the output of the computation (ii) correctness: each party receives the correct output While there are some other properties of MPC like fairness, I just listed the two most intuitive properties, and we will not discuss any security proofs for MPC as this is a simply explained post."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-08-13T17:00:30-04:00"><meta property="article:modified_time" content="2024-08-23T20:06:40+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="A Brief Introduction to Secure Multiparty Computation (MPC)"><meta name=twitter:description content="What Is MPC MPC is a cryptographic protocol that allows some parties to perform some computing tasks while achieving
(i) privacy: no party can know anything except the output of the computation (ii) correctness: each party receives the correct output While there are some other properties of MPC like fairness, I just listed the two most intuitive properties, and we will not discuss any security proofs for MPC as this is a simply explained post."><link rel=canonical href=https://shvier.github.io/posts/2024/0813/a-brief-introduction-to-secure-multiparty-computation/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-[--w] px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-y-[1px] text-2xl font-medium" href=https://shvier.github.io/>Barry's Site</a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-10"><a class="block text-center text-xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-14 lg:mt-0 lg:items-center"><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/barryllvm target=_blank rel=me>twitter
</a><a class="h-7 w-7 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/Shvier target=_blank rel=me>github</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-[--w] px-8 pb-16 pt-14 dark:prose-invert"><article><header class=mb-20><h1 class="!my-0 pb-2.5">A Brief Introduction to Secure Multiparty Computation (MPC)</h1><div class="text-sm opacity-50" style=display:flex;align-items:center><time>Created on Aug 13, 2024</time>
<time>&nbsp•&nbspModified on Aug 23, 2024</time></div></header><section><h2 id=what-is-mpc>What Is MPC</h2><p>MPC is a cryptographic protocol that allows some parties to perform some computing tasks while achieving</p><ul><li>(i) <em>privacy</em>: no party can know anything except the output of the computation</li><li>(ii) <em>correctness</em>: each party receives the correct output</li></ul><p>While there are some other properties of MPC like <em>fairness</em>, I just listed the two most intuitive properties, and we will not discuss any security proofs for MPC as this is a simply explained post.</p><h3 id=security-model>Security Model</h3><p>Formally, we need to indicate what assumptions we are using when solving problems. In MPC, there are two well-known models for security: semi-honest security and malicious security. In the semi-honest security model, even a corrupt party (corrupt party means the party plays the role of the attacker) follows the protocol correctly. The corrupt parties will try to learn as much as possible from the messages exchanged among other parties. We can also say passive adversary. On the other hand, malicious security means the adversaries do not need to follow the protocol but take any actions while exchanging messages. Although the semi-honest security model is a weak assumption as the real adversaries will not need to follow the protocol, it is the basic component for the protocols with more robust security.</p><h2 id=preliminaries>Preliminaries</h2><p>In this section, I will introduce two cryptographic primitives, Shamir&rsquo;s secret sharing and oblivious transfer, as the MPC protocols in the following section heavily rely on these two primitives.</p><h3 id=shamirs-secret-sharing>Shamir&rsquo;s Secret Sharing</h3><p>The basic idea of Shamir&rsquo;s secret sharing exploits the fact that interpolating a $d$-degree polynomial requires at least $d+1$ points. If we treat a polynomial $f$ as the secret (the evaluation of $f(0)$), then we just need to let each party hold an evaluation point of the polynomial. When all the parties share the point they hold, the polynomial can be reconstructed, which means they can know the secret $f(0)$. Formally, we call the number of required points to interpolate the polynomial <strong>threshold</strong>. If there are $n$ parties and any $k$ shares can reconstruct the polynomial, we say this is a $(k,n)$-threshold scheme.</p><h4 id=example>Example</h4><p>Suppose the secret is $S$, and we want a $(k,n)$-threshold scheme. Then we just need to generate a random polynomial with degree $k-1$ and let the constant term equal $S$. We use $f$ and $a_i$ to denote the polynomial and the coefficients respectively. So we have</p>$$
f(x)=S+a_1x+a_2x^2+\cdots+a_{k-1}x^{k-1}
$$<p>Next, we evaluate $f$ for each party. Specifically, we compute $f(1),f(2),\dots,f(n)$ and distribute the evaluations to each party. By the Lagrange interpolation theorem, it is clear that any $k$ evaluation points are sufficient to reconstruct $f$.</p><h3 id=oblivious-transfer>Oblivious Transfer</h3><p>The oblivious transfer is a cryptographic protocol involving two parties, the sender $\mathcal{S}$ and the receiver $\mathcal{R}$, where $\mathcal{S}$ holds some secrets and $\mathcal{R}$ wants to retrieve one or more secrets while $\mathcal{S}$ does not know which secrets $\mathcal{R}$ chose. Here we will see the simplest version, a 1-out-of-2 oblivious transfer based on the discrete logarithm assumption (DL), a.k.a, Bellare-Micali oblivious transfer<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Let $\mathbb{G}$ be a group of prime order $p$ with a generator $g$. Let $H$ be a hash function. $\mathcal{S}$ holds two messages $m_0$ and $m_1$, and $\mathcal{R}$ has a selector bit $b\in\{0,1\}$. $\mathcal{R}$ wants to retrieve one of the messages by the selector $b$. $\mathcal{S}$ and $\mathcal{R}$ run the protocol as follows:</p><ol><li>$\mathcal{S}$ randomly generates $c\stackrel{\$}{\leftarrow}\mathbb{G}_p$ and sends $c$ to $\mathcal{R}$.</li><li>$\mathcal{R}$ randomly chooses $k\stackrel{\$}{\leftarrow}\mathbb{Z}_p$ as the private key of the ElGamal private key, and computes two ElGamal public keys</li></ol>$$y_b\leftarrow{g^k}$$
$$y_{1-b}\leftarrow\frac{c}{g^k}$$<ol start=3><li>$\mathcal{R}$ sends $y_0,y_1$ to $\mathcal{S}$.</li><li>$\mathcal{S}$ checks if $c$ equals $y_0\cdot{y_1}$. If not, $\mathcal{S}$ aborts the protocol.</li><li>$\mathcal{S}$ generates $r_0,r_1\stackrel{\$}{\leftarrow}\mathbb{Z}_p$ and computes two ElGamal ciphertexts using the public keys $y_0,y_1$, denoted by $c_0\leftarrow{(g^{r_0},H(y_0^{r_0})\oplus{m_0})}$ and $c_1\leftarrow{(g^{r_1},H(y_1^{r_1})\oplus{m_1})}$. $\mathcal{S}$ sends $c_0,c_1$ to $\mathcal{R}$.</li><li>$\mathcal{R}$ parses $c_b=(v_l,v_r)$ and decrypts $c_0,c_1$ using the knowledge of $k$: $m_b=H(v_l^k)\oplus{v_r}$.</li></ol><p>Now $\mathcal{R}$ successfully retrieved $m_b$ and $\mathcal{S}$ does not know what $b$ is.</p><h2 id=the-concrete-approach>The Concrete Approach</h2><p>We can convert the computing tasks into polynomials for many cases in MPC like the above example of Shamir&rsquo;s secret sharing. In complexity theory, we are interested in the arithmetic circuit model to compute polynomials because it suffices to perform any computation if the addition gate and the multiplication gate can be computed (may be not efficient in some cases but optimization can be applied). While Yao&rsquo;s Garbled Circuit (GC) is considered the most widely known MPC protocol, I will introduce the BGW protocol first as it is relatively easier to understand.</p><h3 id=bgw-protocol>BGW Protocol</h3><p>In BGW protocol, there are two parties, say, Alice and Bob, computing an arithmetic circuit with their secrets as inputs. The rule is Alice and Bob cannot know each other&rsquo;s secret and they both get the output of the circuit. We use $\alpha$ and $\beta$ to denote their secrets respectively.</p><p>First, consider the addition gate, with input $\alpha$, $\beta$ and output $\gamma$. Alice generates a $1$-degree polynomial $f_1$ such that $f_1(0)=\alpha$ and Bob computes $f_2$ such that $f_2(0)=\beta$. So the question becomes how to compute a polynomial $f$ such that $f=f_1+f_2$ since $\gamma=f(0)=f_1(0)+f_2(0)=\alpha+\beta$. But they cannot compute $f$ directly by exchanging $f_1,f_2$ because this way leaks $\alpha$ and $\beta$. Instead, Alice evaluates $f_1$ at two points $x_1$ and $x_2$, and sends $f_1(x_2)$ to Bob. Similarly, Bob sends $f_2(x_1)$. Note this does not violate the rule because $1$-degree polynomial requires two points to be interpolated, which means Alice cannot learn $\beta$ with $f_2(x_1)$, and neither does Bob learn $\alpha$ with $f_1(x_2)$. Now Alice has $f_1(x_1),f_2(x_1)$ and Bob has $f_1(x_2),f_2(x_2)$, and they want to compute $\gamma=f_1(0)+f_2(0)$. It can be observed that when they add the two values they hold, they can construct a new polynomial, and the new polynomial is identical to $f$! Specifically, let Alice compute $\alpha^\prime=f_1(x_1)+f_2(x_1)$ and Bob compute $\beta^\prime=f_1(x_2)+f_2(x_2)$, and they interpolate a polynomial $f^\prime$ from $\alpha^\prime$ and $\beta^\prime$. The reason why $f^\prime$ equals $f$ is the fact that a polynomial can be represented as coefficient form and evaluation form interchangeably. In other words, when we add two polynomials, it is equivalent to adding the evaluations at the same point of the polynomials, which is exactly the way that Alice and Bob do.</p><p>However, the fact cannot be leveraged directly for multiplication gate because multiplication increases the degree of the polynomial. Recall that the threshold relates to the degree, which means the points that Alice and Bob hold are not sufficient to reconstruct the polynomial $f$. To get around this issue, BGW utilized a tricky way to reduce the degree. The basic idea is, instead of $n$ parties recovering a $2n$-degree polynomial, let $2n+1$ parties distribute a $n$-threshold sharing of their secret to reduce the degree of $f$ to $n$. Why does this work? First, $2n+1$ points can reconstruct the $2n$-degree polynomial $f$. Second, the points of $f$ are $n$-threshold sharing, which means any $n$ parties among the whole set can recover $f$.</p><h3 id=yaos-garbled-circuit>Yao&rsquo;s Garbled Circuit</h3><p>Unlike the idea that the BGW protocol exploits the Lagrange interpolation theorem, Yao&rsquo;s GC approach converts a polynomial into a lookup table. That is, we can create a lookup table for all the evaluations of the polynomial such that the two parties&rsquo; inputs are the entry. If such a lookup table exists, Alice and Bob just need to run a 1-out-of-n oblivious transfer to find the result at the correct position of the table for each evaluation time. There are two parties in Yao&rsquo;s GC, one for garbling the circuit, and the other for evaluating the circuit. Before we dive into the general 2PC, let us see a simple case, the AND gate.</p><p>Suppose Alice holds a bit $b_0$ and Bob holds a bit $b_1$. Alice and Bob want to evaluate the AND result of $b_0$ and $b_1$. They do not want each other to know their own input. Alice plays the role of garbling the circuit, and Bob plays the role of the evaluator. Given the truth table of the AND gate, they run the protocol as follows:</p><ol><li>Alice generates a pair of keys $(k_l^0,k_l^1),(k_r^0,k_r^1)$.</li><li>Alice encrypts the table of the AND gate using the above keys such that
$$
c_{00}=E_{k_l^0,k_r^0}(0) \\
c_{01}=E_{k_l^0,k_r^1}(0) \\
c_{10}=E_{k_l^1,k_r^0}(0) \\
c_{11}=E_{k_l^1,k_r^1}(1)
$$</li><li>Alice sends the 4 ciphertexts to Bob.</li><li>In order to let Bob evaluate the AND gate, Bob needs to know the private key of Alice&rsquo;s input and his input. For Bob&rsquo;s key, Alice cannot send the key to Bob directly because this will tell Alice what Bob&rsquo;s input is. Recall the above oblivious transfer, so Alice and Bob run a 1-out-of-2 oblivious transfer for $(k_r^0,k_r^0)$. For Alice&rsquo;s key, she simply sends the key to Bob.</li><li>Bob decrypts the ciphertexts with the two keys he received. He should compute one correct message and others are garbage.</li></ol><p>Now we can extend the above protocol for the AND gate to any function. Suppose Alice and Bob want to evaluate a polynomial $f(x,y)$, where $x$ is Alice&rsquo;s input, $y$ is Bob&rsquo;s input, and $f$ is a general function: $\{0,1\}^n\times\{0,1\}^n\rightarrow\{0,1\}^*$.</p><ol><li>Alice converts the evaluations of $f$ into a lookup table such that the first column is the possible values of Alice&rsquo;s input $x_i$, the second column is the possible values of Bob&rsquo;s input $y_j$, and the third column is the evaluation of $f(x_i,y_j)$.</li><li>Alice encrypts the lookup table by randomly generating a key to each possible input $x$ and $y$ like she did for the AND gate table.</li><li>Alice sends her key to Bob.</li><li>Alice and Bob run a 1-out-of-|$y_j$| oblivious transfer to let Bob retrieve his key.</li><li>Bob decrypts the table with the two keys.</li></ol><p>Note the MPC protocol in practice requires more robust techniques since the evaluator will know the garbler&rsquo;s input when he successfully decrypts the ciphertext. To solve this, the garbler normally shuffles the encrypted table. Another issue is it is not efficient for the evaluator to decrypt the table row by row. To get around this, we can interpret the partial information of the key as a pointer to the table. The together two improvements are often point-and-permute.</p><h2 id=further-reading>Further Reading</h2><ol><li><a href="https://www.youtube.com/watch?v=NOtsxHoIcWQ&amp;list=PLtieFm4iy3qA6Q86APv90-3CYgz7fWzVg">Lecture by Tal Rabin</a></li><li><a href=https://securecomputation.org/>The MPC Book</a></li></ol><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://crypto.stanford.edu/cs355/18sp/lec6.pdf>https://crypto.stanford.edu/cs355/18sp/lec6.pdf</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></section><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://shvier.github.io/posts/2024/0820/polynomial-interpolation-and-fft/><span class=mr-1.5>←</span><span>Polynomial Interpolation and FFT</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=https://shvier.github.io/posts/2024/0308/explaining-kzg-commitment-scheme/><span>Explaining KZG Commitment Scheme</span><span class=ml-1.5>→</span></a></nav></article></main><footer class="opaco mx-auto flex h-[5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-50"><div class=mr-auto>&copy; 2024
<a class=link href=https://shvier.github.io/>Barry's Site</a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>Theme Paper</a>
<link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.css integrity="sha512-mQwom8Ns4op+H29oDkD/LXO/OsXPvCFfkgZkFAVrhhePzRLU8NUI3Nkm43NhWUSmj3p5Cca2HTEkMQmXQRwDQQ==" crossorigin=anonymous referrerpolicy=no-referrer><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/katex.min.js integrity="sha512-sHSNLECRJSK+BFs7E8DiFc6pf6n90bLI85Emiw1jhreduZhK3VXgq9l4kAt9eTIHYAcuQBKHL01QKs4/3Xgl8g==" crossorigin=anonymous referrerpolicy=no-referrer></script><script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.4/contrib/auto-render.min.js integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" crossorigin=anonymous referrerpolicy=no-referrer onload=renderMathInElement(document.body)></script></footer></body></html>